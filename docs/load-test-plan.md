# 부하 테스트 계획서

## 1. 개요

### 1.1 문서 목적

본 문서는 HH E-Commerce 시스템의 부하 테스트 계획을 정의합니다. 시스템의 성능 한계를 파악하고, 병목 지점을 식별하여 안정적인 서비스 운영을 위한 기준을 수립합니다.

### 1.2 테스트 배경

이커머스 시스템의 특성상 다음과 같은 고부하 상황이 발생할 수 있습니다:

| 상황 | 설명 | 예상 트래픽 |
|------|------|------------|
| 타임세일 | 특정 시간대 집중 트래픽 | 평소 대비 10배 |
| 선착순 쿠폰 | 이벤트 시작 시 동시 접속 | 수천 TPS |
| 신상품 출시 | 상품 상세 페이지 집중 조회 | 평소 대비 5배 |
| 결제 대란 | 동시 주문 요청 폭주 | 수백 TPS |

### 1.3 테스트 도구

| 도구 | 용도 | 선정 이유 |
|------|------|----------|
| **k6** | 부하 테스트 실행 | JavaScript 기반, 실시간 메트릭, CI/CD 통합 용이 |
| **Grafana** | 메트릭 시각화 | k6와 연동, 실시간 대시보드 |
| **Docker** | 테스트 환경 구성 | 리소스 제한 테스트 가능 |

---

## 2. 테스트 대상 선정

### 2.1 선정 기준

| 기준 | 설명 | 가중치 |
|------|------|--------|
| 동시성 제어 복잡도 | 분산 락, DB 락 등 동시성 처리 로직 | 높음 |
| 비즈니스 중요도 | 매출에 직접적인 영향을 미치는 API | 높음 |
| 트래픽 집중 가능성 | 이벤트/프로모션 시 트래픽 폭증 가능성 | 중간 |
| 외부 의존성 | Kafka, Redis 등 외부 시스템 의존도 | 중간 |

### 2.2 테스트 대상 API

#### 우선순위 1: 핵심 트랜잭션 API

| API | 엔드포인트 | 동시성 제어 | 선정 이유 |
|-----|-----------|------------|----------|
| **주문 생성** | `POST /api/orders` | Redisson 사용자 락 + DB Atomic | 재고 차감, 쿠폰 적용, 포인트 결제의 복합 트랜잭션 |
| **쿠폰 발급** | `POST /api/coupons/{id}/issue` | Redis Lua Script | 선착순 이벤트 시 수천 동시 요청 예상 |

#### 우선순위 2: 고빈도 조회 API

| API | 엔드포인트 | 캐시 전략 | 선정 이유 |
|-----|-----------|----------|----------|
| **상품 목록** | `GET /api/products` | Redis TTL 10분 | 메인 페이지 진입 시 필수 호출 |
| **상품 상세** | `GET /api/products/{id}` | Redis TTL 5분 | 구매 전 반드시 조회 |
| **인기 상품** | `GET /api/products/popular` | 스케줄 갱신 | 메인 페이지 노출, 복잡한 집계 쿼리 |

#### 우선순위 3: 보조 API

| API | 엔드포인트 | 동시성 제어 | 선정 이유 |
|-----|-----------|------------|----------|
| **포인트 충전** | `POST /api/point/charge` | Optimistic Lock | 주문 결제와 연관 |
| **장바구니 추가** | `POST /api/carts` | 없음 | 구매 플로우 필수 단계 |

---

## 3. 테스트 유형 및 목적

### 3.1 테스트 유형 정의

| Load Test (부하) | Stress Test (스트레스) | Peak Test (피크) | Endurance Test (내구성) |
|------------------|------------------------|------------------|-------------------------|
| 예상 부하 처리 검증 | 한계 탐색, 임계점 확인 | 순간 폭증, 버스트 대응 | 장시간 안정성, 메모리 누수 탐지 |

### 3.2 테스트별 목적 및 설정

| 테스트 유형 | 목적 | VU (가상 사용자) | 지속 시간 | 성공 기준 |
|------------|------|-----------------|----------|----------|
| **Load Test** | 예상 트래픽에서 정상 동작 확인 | 100 VU | 10분 | 에러율 < 1% |
| **Stress Test** | 시스템 한계점 파악 | 100 → 500 VU (점진 증가) | 15분 | 임계점 식별 |
| **Peak Test** | 순간 트래픽 폭증 대응 | 10 → 300 VU (즉시) | 5분 | 복구 시간 < 30초 |
| **Endurance Test** | 장시간 운영 안정성 | 50 VU | 1시간 | 메모리 증가율 < 5% |

---

## 4. 테스트 시나리오

### 4.1 시나리오 1: 동시 주문 테스트 (Concurrent Order Test)

**목적**: 동일 상품에 대한 동시 주문 시 재고 데이터 무결성 검증

```
[시나리오 흐름]
1. 사전 조건: 상품 A의 재고 = 100개
2. 100명의 사용자가 동시에 상품 A를 1개씩 주문
3. 기대 결과: 정확히 100개 주문 성공, 재고 = 0

[검증 포인트]
- 재고 초과 판매 없음 (overselling 방지)
- 주문 중복 생성 없음
- 모든 성공 주문의 상태 = COMPLETED
```

**테스트 설정**:

| 항목 | 값 |
|------|-----|
| 동시 사용자 | 100 VU |
| 상품 재고 | 100개 |
| 요청 방식 | 동시 요청 (ramping-arrival-rate) |
| 검증 항목 | 최종 재고 = 0, 성공 주문 = 100 |

### 4.2 시나리오 2: 선착순 쿠폰 발급 테스트 (First-Come Coupon Test)

**목적**: 제한된 수량의 쿠폰에 대한 동시 발급 요청 시 정확성 검증

```
[시나리오 흐름]
1. 사전 조건: 쿠폰 수량 = 100개
2. 1,000명의 사용자가 동시에 쿠폰 발급 요청
3. 기대 결과: 정확히 100명만 발급 성공

[검증 포인트]
- 발급 수량 초과 없음
- 중복 발급 없음 (1인 1매)
- 실패 응답의 적절한 에러 메시지
```

**테스트 설정**:

| 항목 | 값 |
|------|-----|
| 동시 사용자 | 1,000 VU |
| 쿠폰 수량 | 100개 |
| 요청 방식 | 동시 요청 (constant-arrival-rate) |
| 검증 항목 | 발급 성공 = 100, 중복 발급 = 0 |

### 4.3 시나리오 3: 혼합 워크로드 테스트 (Mixed Workload Test)

**목적**: 실제 서비스와 유사한 트래픽 패턴에서의 시스템 안정성 검증

**트래픽 비율:**

| 구분 | API | 비율 |
|------|-----|------|
| 읽기 (70%) | 상품 목록 조회 | 40% |
| | 상품 상세 조회 | 20% |
| | 인기 상품 조회 | 10% |
| 쓰기 (25%) | 장바구니 추가 | 15% |
| | 주문 생성 | 10% |
| 이벤트 (5%) | 쿠폰 발급 | 5% |

**테스트 설정**:

| 항목 | 값 |
|------|-----|
| 동시 사용자 | 200 VU |
| 지속 시간 | 30분 |
| 요청 방식 | 가중치 기반 랜덤 |
| 검증 항목 | 전체 에러율 < 1%, p95 < 500ms |

### 4.4 시나리오 4: 스트레스 테스트 (Stress Test)

**목적**: 시스템의 처리 한계 및 임계점 파악

**부하 증가 패턴:**

| 시간(분) | VU | 예상 TPS |
|----------|-----|----------|
| 0-2 | 50 | 100 |
| 2-4 | 100 | 200 |
| 4-6 | 200 | 400 |
| 6-8 | 300 | 600 |
| 8-10 | 400 | 800 |
| 10-12 | 500 | 1000 |
| 12-15 | 500 | (유지) |

**테스트 설정**:

| 항목 | 값 |
|------|-----|
| 시작 VU | 50 |
| 최대 VU | 500 |
| 증가 방식 | 2분마다 단계적 증가 |
| 검증 항목 | 에러율 급증 시점, 응답시간 급증 시점 |

---

## 5. 성능 목표 (SLO)

### 5.1 API별 성능 목표

| API | TPS 목표 | 응답시간 (p95) | 에러율 |
|-----|---------|---------------|--------|
| 상품 목록 조회 | 500 | < 200ms | < 0.1% |
| 상품 상세 조회 | 300 | < 150ms | < 0.1% |
| 인기 상품 조회 | 200 | < 100ms | < 0.1% |
| 주문 생성 | 100 | < 1000ms | < 1% |
| 쿠폰 발급 | 200 | < 500ms | < 5% (수량 소진 제외) |
| 포인트 충전 | 100 | < 300ms | < 0.5% |

### 5.2 시스템 리소스 목표

| 지표 | 정상 범위 | 경고 임계치 | 위험 임계치 |
|------|----------|------------|------------|
| CPU 사용률 | < 60% | 70% | 85% |
| 메모리 사용률 | < 70% | 80% | 90% |
| DB 커넥션 풀 | < 70% | 80% | 95% |
| Redis 메모리 | < 60% | 70% | 85% |

---

## 6. 테스트 환경

### 6.1 인프라 구성

```
┌─────────────────────────────────────────────────────────────────┐
│                        테스트 환경 구성                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌─────────┐      ┌─────────────────┐      ┌─────────────┐    │
│   │   k6    │ ───▶ │  Spring Boot    │ ───▶ │   MySQL     │    │
│   │ (Load)  │      │  Application    │      │   8.0       │    │
│   └─────────┘      └────────┬────────┘      └─────────────┘    │
│                             │                                   │
│                    ┌────────┴────────┐                         │
│                    ▼                 ▼                         │
│              ┌──────────┐     ┌──────────┐                     │
│              │  Redis   │     │  Kafka   │                     │
│              │  7.0     │     │  7.5     │                     │
│              └──────────┘     └──────────┘                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 6.2 Docker 리소스 설정

#### 기본 설정 (Base)

```yaml
# docker-compose.yml
services:
  app:
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 2G
        reservations:
          cpus: '1.0'
          memory: 1G

  mysql:
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 1G

  redis:
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
```

#### 스트레스 테스트용 제한 설정

| 테스트 케이스 | App CPU | App Memory | 목적 |
|--------------|---------|------------|------|
| Case 1 (기본) | 2 cores | 2GB | 기준선 측정 |
| Case 2 (제한) | 1 core | 1GB | 리소스 부족 상황 |
| Case 3 (최소) | 0.5 core | 512MB | 극한 상황 |

### 6.3 테스트 데이터

| 데이터 | 수량 | 비고 |
|--------|------|------|
| 사용자 | 10,000명 | 테스트용 계정 |
| 상품 | 1,000개 | 각 10개 옵션 |
| 재고 | 상품당 1,000개 | 옵션별 |
| 쿠폰 | 100개 | 선착순 테스트용 |

---

## 7. 모니터링 지표

### 7.1 애플리케이션 메트릭

| 지표 | 설명 | 수집 방법 |
|------|------|----------|
| http_request_duration | API 응답시간 | Micrometer |
| http_requests_total | 총 요청 수 | Micrometer |
| jvm_memory_used | JVM 메모리 사용량 | Actuator |
| jvm_gc_pause | GC 일시정지 시간 | Actuator |
| hikari_connections_active | DB 활성 커넥션 | HikariCP |

### 7.2 인프라 메트릭

| 지표 | 설명 | 수집 방법 |
|------|------|----------|
| container_cpu_usage | 컨테이너 CPU 사용률 | Docker Stats |
| container_memory_usage | 컨테이너 메모리 사용률 | Docker Stats |
| redis_memory_used | Redis 메모리 사용량 | Redis INFO |
| kafka_consumer_lag | Kafka 컨슈머 지연 | Kafka Metrics |

### 7.3 비즈니스 메트릭

| 지표 | 설명 | 검증 방법 |
|------|------|----------|
| order_success_rate | 주문 성공률 | DB 쿼리 |
| coupon_issue_count | 쿠폰 발급 수 | DB 쿼리 |
| stock_integrity | 재고 무결성 | 테스트 후 검증 |

---

## 8. 테스트 실행 계획

### 8.1 실행 순서

```
Phase 1: 환경 준비 (30분)
├── Docker 환경 구성
├── 테스트 데이터 초기화
└── 모니터링 도구 설정

Phase 2: 기능 검증 (1시간)
├── 각 API 단독 테스트
├── 정상 응답 확인
└── 기본 성능 측정

Phase 3: 부하 테스트 (2시간)
├── Load Test (30분)
├── Stress Test (30분)
├── Peak Test (30분)
└── Mixed Workload Test (30분)

Phase 4: 결과 분석 (1시간)
├── 메트릭 수집
├── 병목 지점 분석
└── 보고서 작성
```

### 8.2 테스트 체크리스트

| 단계 | 체크 항목 | 완료 |
|------|----------|------|
| 사전 준비 | Docker 컨테이너 정상 실행 | ☐ |
| 사전 준비 | 테스트 데이터 초기화 완료 | ☐ |
| 사전 준비 | k6 스크립트 문법 검증 | ☐ |
| 테스트 | Load Test 완료 | ☐ |
| 테스트 | Stress Test 완료 | ☐ |
| 테스트 | Peak Test 완료 | ☐ |
| 테스트 | Mixed Workload Test 완료 | ☐ |
| 검증 | 재고 무결성 확인 | ☐ |
| 검증 | 쿠폰 발급 수량 확인 | ☐ |
| 분석 | 병목 지점 식별 | ☐ |
| 분석 | 성능 보고서 작성 | ☐ |

---

## 9. 예상 병목 지점

### 9.1 병목 후보 분석

| 구간 | 병목 가능성 | 원인 | 대응 방안 |
|------|------------|------|----------|
| 주문 생성 | 높음 | 사용자별 직렬화 처리 | 락 범위 최소화 |
| 쿠폰 발급 | 중간 | Redis 단일 스레드 | Lua Script 최적화 |
| DB 커넥션 | 중간 | 커넥션 풀 고갈 | 풀 사이즈 조정 |
| Kafka 발행 | 낮음 | 브로커 지연 | 비동기 처리 확인 |

### 9.2 모니터링 우선순위

| 우선순위 | 지표 |
|----------|------|
| **Critical** | 1. API 응답시간 (p95, p99) |
| | 2. 에러율 |
| | 3. DB 커넥션 사용률 |
| **Warning** | 4. JVM 힙 메모리 |
| | 5. Redis 메모리 |
| | 6. Kafka Consumer Lag |
| **Info** | 7. CPU 사용률 |
| | 8. GC 횟수 및 시간 |

---

## 10. 결과물

### 10.1 산출물 목록

| 산출물 | 설명 | 형식 |
|--------|------|------|
| k6 테스트 스크립트 | 시나리오별 테스트 코드 | JavaScript |
| 테스트 결과 리포트 | k6 실행 결과 | HTML/JSON |
| 성능 분석 보고서 | 지표 분석 및 개선안 | Markdown |
| 장애 대응 문서 | 가상 장애 시나리오 대응 | Markdown |

### 10.2 성공 기준

| 항목 | 기준 |
|------|------|
| 데이터 무결성 | 재고/쿠폰 수량 정확성 100% |
| 성능 목표 달성 | SLO 기준 충족 |
| 병목 식별 | 최소 1개 이상 병목 지점 발견 및 분석 |
| 개선안 도출 | 구체적인 개선 방안 제시 |

---

## 부록 A: 참고 자료

- [k6 Documentation](https://k6.io/docs/)
- [Spring Boot Actuator Metrics](https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html)
- [프로젝트 동시성 제어 문서](./concurrency.md)
- [Redis 성능 개선 보고서](./redis-performance-report.md)
- [Kafka 성능 분석 보고서](./kafka-performance-report.md)
